# generated by datamodel-codegen:
#   filename:  openapi.yaml

from __future__ import annotations
from pydantic import BaseModel, ConfigDict, Field, RootModel
from typing import Annotated, Any
from enum import Enum


class HttpError(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    detail: str | list[str]


class IsccIndex(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: Annotated[
        str,
        Field(
            description="Short unique name of the index (valid code identifier)",
            examples=["default"],
            max_length=32,
            min_length=1,
            pattern="^[a-z][a-z0-9]*$",
        ),
    ]
    assets: Annotated[
        int | None,
        Field(description="Number of ISCCs in the index (server-generated, read-only)", examples=[150000], ge=0),
    ] = None
    size: Annotated[
        int | None, Field(description="Size of index in megabytes (server-generated, read-only)", examples=[42], ge=0)
    ] = None


class IsccSimprint(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    simprint: Annotated[
        str,
        Field(
            description="Base64-encoded simprint hash (headerless, variable length).\n\nTypical lengths:\n- 128-bit: 22 chars (base64url without padding)\n- 256-bit: 42 chars (without padding)\n",
            examples=["AXvu3tp2kF8mN9qL4rT1sZ"],
            min_length=16,
            pattern="^[A-Za-z0-9+/_=-]+$",
        ),
    ]
    offset: Annotated[
        int,
        Field(
            description="Starting position/time/coordinates in the source content.\n\n**Interpretation by modality**:\n- Text: UTF-8 byte offset (0-indexed)\n- Audio/Video: Milliseconds from start (0-indexed)\n- Image: Packed coordinates (x << 16 | y)\n\nSee IsccChunk documentation for detailed semantics.\n",
            examples=[12500],
            ge=0,
            le=4294967295,
        ),
    ]
    size: Annotated[
        int,
        Field(
            description="Extent/duration/dimensions of the content segment.\n\n**Interpretation by modality**:\n- Text: UTF-8 byte length\n- Audio/Video: Duration in milliseconds\n- Image: Packed dimensions (width << 16 | height)\n\nSee IsccChunk documentation for detailed semantics.\n",
            examples=[350],
            ge=0,
            le=4294967295,
        ),
    ]


class Unit(RootModel[str]):
    root: Annotated[str, Field(pattern="^ISCC:[A-Z2-7]{16,}$")]


class Simprint(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="Base64-encoded simprint hash (url-safe or standard base64). Typical lengths:\n- 128-bit: 22 chars (base64url without padding)\n- 256-bit: 43 chars (base64 with padding) or 42 chars (without)\n",
            examples=["AXvu3tp2kF8mN9qL4rT1sZ"],
            pattern="^[A-Za-z0-9+/_=-]+$",
        ),
    ]


class IsccQuery(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    iscc_id: Annotated[
        str | None,
        Field(
            description='ISCC-ID of a known indexed asset to use as similarity reference. The backend\nretrieves the stored units for this ID and searches for similar assets.\n\n**Use case**: "Find assets similar to ISCC:MAI..." (more-like-this query)\n\n**Precedence**: When provided, `iscc_id` takes precedence over all other query\nfields. Any provided `iscc_code`, `units`, or `simprints` are ignored.\n\n**Behavior**:\n- Backend looks up iscc_id → units in storage\n- Performs similarity search with those units\n- Returns matches excluding the query asset itself (no self-match)\n\n**Error handling**: Returns HTTP 404 if iscc_id is not found in the index.\n',
            examples=["ISCC:MAIGIIFJRDGEQQAA"],
            pattern="^ISCC:[A-Z2-7]{16,}$",
        ),
    ] = None
    iscc_code: Annotated[
        str | None,
        Field(
            description="Composite ISCC-CODE combining multiple ISCC-UNITs. The system automatically\nextracts individual units for parallel search across unit-specific indexes.\n",
            examples=["ISCC:KADUHBUDQUT3LPWRJH6BUAG7HMBIXX6JRQRX3JH7EBIOSMXEVL5URBBUPOIOTU4HLSSQ"],
            pattern="^ISCC:[A-Z2-7]{16,}$",
        ),
    ] = None
    units: Annotated[
        list[Unit] | None,
        Field(
            description="Explicit list of ISCC-UNITs for asset-level matching. Can be used instead of\nor in addition to `iscc_code` for fine-grained control over which units are queried.\n",
            examples=[
                [
                    "ISCC:AAAUHBUDQUT3LPWR",
                    "ISCC:CAAUT7A2ADPTWAUL",
                    "ISCC:EAA57SMMEN62J7ZA",
                    "ISCC:GAAVB2JS4SVPWSEE",
                    "ISCC:IAATI64Q5HJYOXFF",
                ]
            ],
            min_length=1,
        ),
    ] = None
    simprints: Annotated[
        dict[str, list[Simprint]] | None,
        Field(
            description='Simprint groups for chunk-level matching. Keys are simprint type identifiers\n(e.g., "CONTENT_TEXT_V0", "SEMANTIC_TEXT_V0", "INSTANCE_NONE_V0"), values are\narrays of headerless base64-encoded simprints.\n\n**Simprint types** are versioned identifiers that determine:\n- Matching strategy (exact collision vs approximate similarity)\n- Abstraction level (semantic vs content vs data)\n- Segmentation approach (sentence chunks, embedding windows, etc.)\n\n**Extensibility**: New simprint types can be added without schema changes.\nUnknown types are ignored gracefully.\n\n**Common types**:\n- `CONTENT_TEXT_V0`: Lexical similarity (near-duplicates, minor edits)\n- `SEMANTIC_TEXT_V0`: Conceptual similarity (paraphrases, translations)\n- `INSTANCE_NONE_V0`: Exact bitstream matches (cryptographic identity)\n',
            examples=[
                {
                    "CONTENT_TEXT_V0": ["AXvu3tp2kF8mN9qL4rT1sZ", "B4kl9mQ1pP7xY3jH8vW2aF"],
                    "SEMANTIC_TEXT_V0": ["CYhq2nR8oL3pT5mK9sX4bG", "D9mn7vT4qK2rU6nL1tY5cH", "E1pj8wU5rM9sV7oN2uZ6dJ"],
                }
            ],
        ),
    ] = None


class Status(str, Enum):
    created = "created"
    updated = "updated"


class IsccAddResult(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    iscc_id: Annotated[
        str,
        Field(
            description="The ISCC-ID of the asset that was added to the index (must be provided in add request)",
            examples=["ISCC:MAIGIIFJRDGEQQAA"],
            pattern="^ISCC:[A-Z2-7]{16,}$",
        ),
    ]
    status: Annotated[
        Status,
        Field(
            description='Outcome of the add operation. "created" means asset was newly added to the index,\n"updated" means asset already existed (duplicate skipped via dupdata=False).\n',
            examples=["created"],
        ),
    ]


class IsccGlobalMatch(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    iscc_id: Annotated[
        str,
        Field(
            description="The matched ISCC-ID from the index",
            examples=["ISCC:MAIGIIFJRDGEQQAA"],
            pattern="^ISCC:[A-Z2-7]{16,}$",
        ),
    ]
    score: Annotated[
        float,
        Field(
            description="Aggregated score across all unit_types. Metric semantics (bit-length, NPHD distance, etc.)\nare defined at the result collection level, not per match.\n",
            examples=[448],
            ge=0.0,
        ),
    ]
    types: Annotated[
        dict[str, float],
        Field(
            description='Per-unit_type scores. Keys are unit type names (e.g., "CONTENT_TEXT_V0"),\nvalues are numeric scores whose semantics depend on the search backend\n(bit-length for lookup index, NPHD distance for usearch, etc.).\n',
            examples=[{"CONTENT_TEXT_V0": 256, "DATA_NONE_V0": 128, "INSTANCE_NONE_V0": 64}],
        ),
    ]


class IsccEntry(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    iscc_id: Annotated[
        str | None,
        Field(
            description="Globally unique digital asset identifier (ISCC-ID)",
            examples=["ISCC:MAIGIIFJRDGEQQAA"],
            pattern="^ISCC:[A-Z2-7]{16,}$",
        ),
    ] = None
    iscc_code: Annotated[
        str | None,
        Field(
            description="Composite ISCC-CODE combining multiple ISCC-UNITs",
            examples=["ISCC:KECYCMZIOY36XXGZ7S6QJQ2AEEXPOVEHZYPK6GMSFLU3WF54UPZMTPY"],
            pattern="^ISCC:[A-Z2-7]{16,}$",
        ),
    ] = None
    units: Annotated[
        list[str] | None,
        Field(description="List of ISCC-UNITs as canonical strings (variable-length, 64-256 bits)", min_length=2),
    ] = None
    simprints: Annotated[
        dict[str, list[IsccSimprint]] | None,
        Field(
            description='Simprint groups for chunk-level indexing. Keys are simprint type identifiers\n(e.g., "CONTENT_TEXT_V0", "SEMANTIC_TEXT_V0"), values are arrays of simprint\nentries with location metadata.\n\n**Simprint types** are versioned identifiers determining matching strategy and\nabstraction level:\n- `CONTENT_TEXT_V0`: Lexical similarity (near-duplicates, minor edits)\n- `SEMANTIC_TEXT_V0`: Conceptual similarity (paraphrases, translations)\n- `INSTANCE_NONE_V0`: Exact bitstream matches (cryptographic identity)\n\n**Extensibility**: New simprint types can be added without schema changes.\n\n**Storage**: Each simprint is indexed with its parent iscc_id, enabling reverse\nlookup from simprint → chunks → assets.\n',
            examples=[
                {
                    "CONTENT_TEXT_V0": [
                        {"simprint": "AXvu3tp2kF8mN9qL4rT1sZ", "offset": 12500, "size": 350},
                        {"simprint": "B4kl9mQ1pP7xY3jH8vW2aF", "offset": 45230, "size": 412},
                    ],
                    "SEMANTIC_TEXT_V0": [
                        {"simprint": "CYhq2nR8oL3pT5mK9sX4bG", "offset": 78900, "size": 389},
                        {"simprint": "D9mn7vT4qK2rU6nL1tY5cH", "offset": 123450, "size": 301},
                    ],
                }
            ],
        ),
    ] = None
    metadata: Annotated[
        dict[str, Any] | None,
        Field(
            description="Optional application-specific metadata. This field allows clients to store\ncustom data without requiring API changes. The server stores this data\nopaquely without validation.\n",
            examples=[
                {
                    "source": "example.com",
                    "uploaded_by": "user123",
                    "content_type": "image/jpeg",
                    "tags": ["nature", "landscape"],
                }
            ],
        ),
    ] = None


class IsccSearchResult(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    query: Annotated[IsccEntry, Field(description="The original query asset (may include auto-generated iscc_id)")]
    global_matches: Annotated[
        list[IsccGlobalMatch],
        Field(
            description="Asset-level ISCC-UNIT matches, ordered by relevance (best first)",
            examples=[
                [
                    {
                        "iscc_id": "ISCC:MAIGIIFJRDGEQQAA",
                        "score": 448,
                        "matches": {"CONTENT_TEXT_V0": 256, "DATA_NONE_V0": 128, "INSTANCE_NONE_V0": 64},
                    },
                    {
                        "iscc_id": "ISCC:MAIGXXFZRDGEQQBB",
                        "score": 384,
                        "matches": {"CONTENT_TEXT_V0": 256, "DATA_NONE_V0": 128},
                    },
                ]
            ],
        ),
    ]
