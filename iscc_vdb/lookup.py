"""
# IsccLookupIndex - Index for fast UNIT-based ISCC lookups

## Design

IsccLookupIndex wraps an LMDB environment with individual per ISCC-UNIT-TYPE inverted index dbs (unit -> iscc_id) for
fast prefix-based lookup. For reference see iscc_vdb/instance.py. Make sure we use convenience classes
from iscc_vdb/types.py extensively in our implementation.

## Api
class IsccLookupIndex
    def add(iscc_items):
        # type: (IsccItemDict | list[IsccItemDict]) -> list[str]

    def search(iscc_items):
        # type: (IsccItemDict | list[IsccItemDict]) -> list[IsccLookupResultDict]


**Example Usage**

```python
from iscc_vdb import IsccLookupIndex

idx = IsccLookupIndex()

# Add a single ISCC-CODE

iscc_item = dict(
    iscc_id="ISCC:MAIGIGAPWHP6WYAA",
    iscc_code="ISCC:KMDEQJUGOMR2O4I2QEZSQ5RX5PONT2D2CYJ6IQ67PCKVRBT7LOUR7LY",
)

iscc_ids = idx.add(iscc_items=iscc_item)

# Add a single ISCC-CODE from extended ISCC-UNITs

iscc_item = dict(
    iscc_id = "ISCC:MAIGIGASLOLROAAA"
    iscc_units = [
        "AADYQVQXCLUOKILK7S6QJQ2AEEXPPTFFUWQZ4TLOHQMENVBEYF6GE6I",
        "EQD5TOFHCTTBURA4CLQMRMV22ZAPWGKIRXWE6ZOU3ESZ6QZJ432FSCY",
        "GAD2H4WJX6OGGFVZKDZEIVLPEXRKEWUSCGDRTR4N6SHU74Y6PDPFQVY",
        "IADQ74MOAJBK7H6DQV3W5GW5QTZZ44KULIJXUHKQA2GXEMIE65ZYHQI",
    ]
)
iscc_ids = idx.add(iscc_items=iscc_item)

# Add multiple ISCC-CODEs

iscc_items = [iscc_item, ...]
iscc_ids = idx.add(iscc_items=iscc_items)

Note: if iscc_id is missing from IsccItemDict an ISCC-ID wiil be autogenerated and returned

result = idx.search(iscc_item)
```

result structure:

{
    lookup_matches: [
    {
        iscc_id: ...,
        score:
        meta: 64,
        semantic: 0,
        content: 128,
        data: 64,
        intance: 0
    ]
}

where score is the sum of all matched bits
meta, semantic, content, data, instance signify the number of exact overlaping prefix bits per unit.
"""

import os
from typing import Any, TypedDict
import lmdb
import iscc_core as ic
from loguru import logger
from iscc_vdb.types import IsccItemDict, IsccItem, IsccUnit


class IsccLookupMatchDict(TypedDict):
    """Single lookup match result with ISCC-ID and bit overlap scores."""

    iscc_id: str
    score: int
    meta: int
    semantic: int
    content: int
    data: int
    instance: int


class IsccLookupResultDict(TypedDict):
    """Lookup result containing list of matches for a query."""

    lookup_matches: list[IsccLookupMatchDict]


class IsccLookupIndex:
    """
    LMDB-backed lookup index for ISCC-UNIT prefix search.

    Organizes ISCC-UNITs by their unit_type in separate named databases.
    Supports prefix-based matching and aggregated scoring across unit types.
    """

    DEFAULT_LMDB_OPTIONS = {
        "readonly": False,
        "metasync": False,
        "sync": False,
        "mode": 0o644,
        "create": True,
        "readahead": False,
        "writemap": True,
        "meminit": True,
        "map_async": False,
        "max_readers": 126,
        "max_spare_txns": 16,
        "lock": True,
    }

    def __init__(self, path, realm_id=0, lmdb_options=None):
        # type: (os.PathLike, int, dict[str, Any] | None) -> None
        """
        Create or open LMDB lookup index.

        :param path: Directory path for LMDB environment
        :param realm_id: ISCC realm ID for ISCC-ID reconstruction (default 0)
        :param lmdb_options: Optional LMDB environment options
        """
        self.path = os.fspath(path)
        self.realm_id = realm_id

        # Merge user options with defaults
        options = self.DEFAULT_LMDB_OPTIONS.copy()
        if lmdb_options:
            options.update(lmdb_options)

        # Force internal parameters
        options["max_dbs"] = 32  # Support multiple unit types
        options["subdir"] = False

        self.env = lmdb.open(self.path, **options)
        self._db_cache = {}  # type: dict[str, Any]  # Cache opened databases

    def add(self, iscc_items):
        # type: (IsccItemDict | list[IsccItemDict]) -> list[str]
        """
        Add ISCC items to the lookup index.

        Extracts units from each item and stores them in unit_type-specific databases.
        Generates ISCC-IDs for items that don't have one.

        :param iscc_items: Single IsccItemDict or list of IsccItemDicts
        :return: List of ISCC-ID strings (generated or provided)
        """
        items = self._normalize_input(iscc_items)
        iscc_ids = []

        while True:
            try:
                with self.env.begin(write=True) as txn:
                    for item in items:
                        # Convert to IsccItem (generates ISCC-ID if missing)
                        iscc_item = IsccItem.from_dict(item)
                        iscc_ids.append(iscc_item.iscc_id)

                        # Extract ISCC-ID body (8 bytes)
                        iscc_id_body = iscc_item.id_data[2:]

                        # Process each unit
                        for unit_str in iscc_item.units:
                            unit = IsccUnit(unit_str)
                            unit_type = unit.unit_type

                            # Get or create database for this unit type
                            db = self._get_or_create_db(unit_type, txn)

                            # Store: key=unit_body, value=iscc_id_body
                            # Use dupdata=False to prevent duplicate ISCC-IDs per unit
                            cursor = txn.cursor(db)
                            cursor.put(unit.body, iscc_id_body, dupdata=False)

                # Success - break out of retry loop
                break

            except lmdb.MapFullError:
                # Clear accumulated IDs since we're retrying
                iscc_ids = []
                old_size = self.map_size
                new_size = old_size * 2
                logger.info(f"IsccLookupIndex map_size increased from {old_size:,} to {new_size:,} bytes")
                self.env.set_mapsize(new_size)
                # Clear database cache since handles are invalid after resize
                self._db_cache = {}
                # Loop will retry with new map_size

        return iscc_ids

    def search(self, iscc_items, limit=100):
        # type: (IsccItemDict | list[IsccItemDict], int) -> list[IsccLookupResultDict]
        """
        Search for matching ISCC-IDs based on unit prefix overlap.

        For each query item, finds stored units with matching prefixes and calculates
        bit overlap scores aggregated by ISCC-ID and unit type.

        :param iscc_items: Single IsccItemDict or list of IsccItemDicts
        :param limit: Maximum number of matches to return per query (default: 100)
        :return: List of IsccLookupResultDict, one per query item
        """
        items = self._normalize_input(iscc_items)
        results = []

        with self.env.begin() as txn:
            for item in items:
                # Convert to IsccItem
                iscc_item = IsccItem.from_dict(item)

                # Accumulate matches: iscc_id -> {main_type -> max_bits}
                matches = {}  # type: dict[str, dict[str, int]]

                # Process each query unit
                for unit_str in iscc_item.units:
                    unit = IsccUnit(unit_str)
                    unit_type = unit.unit_type

                    # Skip if database doesn't exist for this unit type
                    db = self._get_db(unit_type, txn)
                    if db is None:
                        continue

                    # Find matching units with prefix search
                    unit_matches = self._search_unit(txn, db, unit)

                    # Aggregate matches by ISCC-ID
                    for iscc_id, matched_bits in unit_matches.items():
                        if iscc_id not in matches:
                            matches[iscc_id] = {
                                "meta": 0,
                                "semantic": 0,
                                "content": 0,
                                "data": 0,
                                "instance": 0,
                            }

                        # Map unit type to main type
                        main_type = self._get_main_type(unit)
                        # Keep maximum bits matched for this main type
                        matches[iscc_id][main_type] = max(matches[iscc_id][main_type], matched_bits)

                # Calculate scores and sort
                lookup_matches = []
                for iscc_id, type_scores in matches.items():
                    total_score = sum(type_scores.values())
                    match_dict = IsccLookupMatchDict(
                        iscc_id=iscc_id,
                        score=total_score,
                        meta=type_scores["meta"],
                        semantic=type_scores["semantic"],
                        content=type_scores["content"],
                        data=type_scores["data"],
                        instance=type_scores["instance"],
                    )
                    lookup_matches.append(match_dict)

                # Sort by total score (descending) and limit results
                lookup_matches.sort(key=lambda x: x["score"], reverse=True)
                lookup_matches = lookup_matches[:limit]

                results.append(IsccLookupResultDict(lookup_matches=lookup_matches))

        return results

    def close(self):
        # type: () -> None
        """Close LMDB environment."""
        self.env.close()

    @property
    def map_size(self):
        # type: () -> int
        """Get current map_size from LMDB environment."""
        return self.env.info()["map_size"]

    def __del__(self):
        # type: () -> None
        """Cleanup on deletion."""
        if hasattr(self, "env"):
            self.env.close()

    # Helper methods

    def _normalize_input(self, iscc_items):
        # type: (IsccItemDict | list[IsccItemDict]) -> list[IsccItemDict]
        """Normalize input to list of IsccItemDict."""
        if isinstance(iscc_items, dict):
            return [iscc_items]
        return iscc_items

    def _get_or_create_db(self, unit_type, txn):
        # type: (str, lmdb.Transaction) -> Any
        """
        Get or create a database for the given unit type.

        :param unit_type: ISCC unit type string (e.g., "CONTENT-TEXT-V1")
        :param txn: Active LMDB transaction
        :return: Database handle
        """
        if unit_type in self._db_cache:
            return self._db_cache[unit_type]

        db = self.env.open_db(
            unit_type.encode("utf-8"),
            txn=txn,
            dupsort=True,
            dupfixed=True,
            integerdup=True,
        )
        self._db_cache[unit_type] = db
        return db

    def _get_db(self, unit_type, txn):
        # type: (str, lmdb.Transaction) -> Any | None
        """
        Get database for unit type (returns None if doesn't exist).

        :param unit_type: ISCC unit type string
        :param txn: Active LMDB transaction
        :return: Database handle or None
        """
        if unit_type in self._db_cache:
            return self._db_cache[unit_type]

        try:
            db = self.env.open_db(unit_type.encode("utf-8"), txn=txn, create=False)
            self._db_cache[unit_type] = db
            return db
        except lmdb.NotFoundError:
            return None

    def _search_unit(self, txn, db, unit):
        # type: (lmdb.Transaction, Any, IsccUnit) -> dict[str, int]
        """
        Search for matching units in database using prefix matching.

        :param txn: Active LMDB transaction
        :param db: Database handle
        :param unit: Query unit
        :return: Dict mapping ISCC-ID to matched bits
        """
        matches = {}  # type: dict[str, int]
        cursor = txn.cursor(db)
        query_body = unit.body
        query_bits = len(unit)

        # Search for stored units that start with query prefix (forward search)
        if cursor.set_range(query_body):
            for key, value in cursor:
                if not key.startswith(query_body):
                    break
                # Stored unit starts with query - matched bits = query length
                iscc_id = self._bytes_to_iscc_id(value)
                # Keep maximum matched bits for this ISCC-ID
                matched_bits = query_bits
                matches[iscc_id] = max(matches.get(iscc_id, 0), matched_bits)

        # Also search for query prefixes in stored units (reverse search)
        # Try shorter versions of the query
        for bit_length in [64, 128, 192]:
            if bit_length >= query_bits:
                continue

            prefix = query_body[: bit_length // 8]
            if cursor.set_range(prefix):
                for key, value in cursor:
                    if not key.startswith(prefix):
                        break
                    # Check if this is truly a prefix match (not just range)
                    if query_body.startswith(key):
                        iscc_id = self._bytes_to_iscc_id(value)
                        matched_bits = len(key) * 8
                        matches[iscc_id] = max(matches.get(iscc_id, 0), matched_bits)

        return matches

    def _bytes_to_iscc_id(self, digest):
        # type: (bytes) -> str
        """Convert 8-byte ISCC-ID body to canonical string."""
        if self.realm_id == 0:
            header = ic.encode_header(ic.MT.ID, 0, ic.VS.V1, 0)
        elif self.realm_id == 1:
            header = ic.encode_header(ic.MT.ID, 1, ic.VS.V1, 0)
        else:
            raise ValueError(f"Invalid realm_id {self.realm_id}, must be 0 or 1")
        return "ISCC:" + ic.encode_base32(header + digest)

    @staticmethod
    def _get_main_type(unit):
        # type: (IsccUnit) -> str
        """Get lowercase main type name from unit."""
        mt = ic.MT(unit.fields[0])
        return mt.name.lower()
